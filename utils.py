# -*- coding: utf-8 -*-
"""utils.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FicIY-KMrVUEm7r2FdBSOxxKn5CHet6W
"""

# install necessary packages
# !pip install selectivesearch
# !pip install torch_snippets

from torch_snippets import *
import selectivesearch
from skimage.segmentation import felzenszwalb
import matplotlib.pyplot as plt

# SelectiveSearch begins
def extract_candidates(img, min_area=.1, max_area=.75):
    '''
        type(img): <class 'numpy.ndarray'>
    '''
    img_lbl, regions = selectivesearch.selective_search(img, scale=400, min_size=100)
    # regions : list of dictionaries, i.e. {'labels': [1.0, ...], 'rect': (528, 0, 171, 0), 'size': 172}
    img_area = np.prod(img.shape[:2])
    candidates = []
    for r in regions:
        if r['rect'] in candidates: continue
        if r['size'] < (min_area*img_area): continue
        if r['size'] > (max_area*img_area): continue
        x, y, w, h = r['rect']
        candidates.append(list(r['rect']))
    return candidates
# SelectiveSearch ends

# intersection over union starts
def get_iou(boxA, boxB, epsilon=1e-5):
    '''
        boxA: (list) ground truth bbox
        boxB: (list) region proposal bbox
        epsilon: (float) to avoid ZeroDivisionError
    '''
    x1 = max(boxA[0], boxB[0])
    y1 = max(boxA[1], boxB[1])
    x2 = min(boxA[2], boxB[2])
    y2 = min(boxA[3], boxB[3])
    width = x2 - x1
    height = y2 - y1
    if (width <= 0) or (height <= 0):
        return 0.
    intersection = width * height # area of overlap

    area_a = (boxA[2] - boxA[0]) * (boxA[3] - boxA[1])
    area_b = (boxB[2] - boxB[0]) * (boxB[3] - boxB[1])
    union = area_a + area_b - intersection # combined area of overlap 

    return intersection / (union + epsilon)
# intersection over union ends



